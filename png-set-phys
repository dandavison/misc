#!/usr/bin/env emacs --script
(let ((package-load-list '((dash t) (s t) (f t)))) (package-initialize))
(require 'f)

;; PNG spec https://www.w3.org/TR/PNG-Structure.html
;;
;; E.g.
;;
;; ┌────────┬─────────────────────────┬─────────────────────────┬────────┬────────┐
;; │00000000│ 89 50 4e 47 0d 0a 1a 0a ┊ 00 00 00 0d 49 48 44 52 │×PNG__•_┊000_IHDR│
;; │00000010│ 00 00 00 64 00 00 00 1d ┊ 08 02 00 00 00 d3 ad 5e │000d000•┊••000××^│
;; │00000020│ 0a 00 00 00 09 70 48 59 ┊ 73 00 00 0e c4 00 00 0e │_000_pHY┊s00•×00•│
;; │00000030│ c4 01 95 2b 0e 1b 00 00 ┊ 02 ab 49 44 41 54 68 05 │×•×+••00┊•×IDATh•│
;;
;; 01-08: The signature:
;;            89 50 4e 47 0d 0a 1a 0a
;;        (--map (format "%02x" it) '(137 80 78 71 13 10 26 10))
;;         ==> ("89" "50" "4e" "47" "0d" "0a" "1a" "0a")
;;
;; 09-12: IHDR length (13):
;;                                      00 00 00 0d
;;
;; 13-16: IHDR type (IHDR):
;;                                                  49 48 44 52
;;        (--map (char-to-string (string-to-number it 16)) '("49" "48" "44" "52"))
;;        ==> ("I" "H" "D" "R")
;;
;; 17-29: IHDR data:
;;           00 00 00 64 00 00 00 1d | 08 02 00 00 00
;;
;; 30-33: IHDR CRC:
;;                                                    d3 ad 5e
;;           0a
;;
;; 34-37: pHYs length (9)
;;              00 00 00 09
;;
;; 38-41: pHYs type (pHYs)
;;                          70 48 59 ┊ 73
;;        (--map (char-to-string (string-to-number it 16)) '("70" "48" "59" "73"))
;;        ==> ("p" "H" "Y" "s")
;;
;; 42-50: pHYs data
;;                                        00 00 0e c4 00 00 0e
;;             c4 01
;;        Pixels per unit, X axis: 4 bytes (unsigned integer)
;;                                        00 00 0e c4
;;                                        (string-to-number "ec4" 16)
;;                                        ==> 3780
;;        Pixels per unit, Y axis: 4 bytes (unsigned integer)
;;                                                    00 00 0e
;;             c4
;;                                        ==> 3780
;;        Note that 1in = 0.0254m and (* 3780 0.0254) ==> 96.012
;;
;;        Unit specifier:          1 byte
;;                01
;;
;; 51-54: pHYs crc32 checksum
;;
;; 4.2.5. pHYs Physical pixel dimensions
;; The pHYs chunk specifies the intended pixel size or aspect ratio for display of the image. It contains:
;;    Pixels per unit, X axis: 4 bytes (unsigned integer)
;;    Pixels per unit, Y axis: 4 bytes (unsigned integer)
;;    Unit specifier:          1 byte
;; The following values are legal for the unit specifier:
;;    0: unit is unknown
;;    1: unit is the meter
;; When the unit specifier is 0, the pHYs chunk defines pixel aspect ratio only;
;; the actual size of the pixels remains unspecified.
;; Conversion note: one inch is equal to exactly 0.0254 meters.
;;
;;
;; So we want to do the following:
;;
;; 1. Substitute bytes 42-45 with the requested pixels-per-unit value
;; 2. Substitute bytes 46-49 with the requested pixels-per-unit value
;; 3. Ensure that byte 50 is 01
;;
;; Usage: png-set-phys ppi infile outfile


;; The crc32 polynomial used for PNG is
;; x^32 + x^26 + x^23 + x^22 + x^16 + x^12 + x^11 + x^10 + x^8 + x^7 + x^5 + x^4 + x^2 + x + 1

;; 3 33222222 22221111 11111100 00000000
;; 2 10987654 32109876 54321098 76543210

;; 1 00000100 11000001 00011101 10110111
;; 1    0   4   12   1    1  13   11   7
;; 1       04       C1       1D       B7

(defun png-set-phys (ppi in-file out-file)
  (let* ((m/i 0.0254)
         (ppm (round (/ ppi m/i)))
         (in-bytes (f-read-bytes in-file))
         (out-bytes)
         (phys-bytes)
         (i 0))
    (assert (< ppm #xFFFFFFFF))
    (dolist (byte (append in-bytes nil))
      (setq i (1+ i))
      (cond
       ((or (< i 42)
            (> i 54))
        (push byte out-bytes))
       ((= i 42)
        (setq phys-bytes '(#x70 #x48 #x59 #x73)) ;; p H Y s
        (dolist (_ '(x y))
          (dolist (ppm-byte (png-phys-unpack ppm))
            (push ppm-byte out-bytes)
            (push ppm-byte phys-bytes)))
        (push 1 out-bytes)
        (push 1 phys-bytes)
        (dolist (crc32-byte (png-phys-crc32-13 (nreverse phys-bytes)))
          (push crc32-byte out-bytes)))))
    (f-write-bytes (apply #'unibyte-string (nreverse out-bytes)) out-file)))

(defun png-phys-crc32-13 (phys-bytes)
  "Return crc32 checksum of PHYS-BYTES.

PHYS-BYTES is a list of 13 bytes (4 bytes type + 9 bytes data).
The return value is a 32-bit word, represented as a list of
bytes. In both cases, a byte is represented as an integer in the
range 0-255.

See https://www.w3.org/TR/PNG-Structure.html#CRC-algorithm

Algorithm here based on the following from https://www.zlib.net/crc_v3.txt:

  To perform the division perform the following:

  Load the register with zero bits.
  Augment the message by appending W zero bits to the end of it.
  While (more message bits)
     Begin
     Shift the register left by one bit, reading the next bit of the
        augmented message into register bit position 0.
     If (a 1 bit popped out of the register during step 3)
        Register = Register XOR Poly.
     End
    The register now contains the remainder."
  ;; The input is a list of 13 integers in the range 0-255.
  (assert (eq (length phys-bytes) 13))
  (cl-flet ((msb (word) (if (> word #xFFFFFFF) 1 0)))
    (let* ((polynomial #x04C11DB7)
           (phys-words (png-phys-pack-13 phys-bytes))
           (augmented-phys-words (append phys-words '(0)))
           (register 0))
      (dolist (word augmented-phys-words)
        (dolist (_ (-repeat 32 nil))
          (let ((register-msb (msb register)))

            ;; Left shift the register
            (setq register (lsh register 1))

            ;; Copy the MSB of the message into the LSB of the register.
            (setq register (logior register (msb word)))

            (if (eq register-msb 1)
                ;; If a 1 popped off the register, xor the register with the polynomial.
                (setq register (logxor register polynomial)))

            ;; Left shift the message.
            (setq word (lsh word 1)))))

      ;; Return contents of register as list of 4 bytes
      (png-phys-unpack register))))

(ert-deftest png-phys-crc32-13 ()
  ;; Consider pHYs chunk data
  ;; <-- type -> <--- x ---> <--- y ---> unit
  ;; 70 48 59 73 00 00 93 a3 00 00 93 a3 01
  ;; The crc32 of this is 0xD1B2F0C6:
  ;; "%x" % crc32(b"\x70\x48\x59\x73\x00\x00\x93\xa3\x00\x00\x93\xa3\x01")
  ;; ==> 'd1b2f0c6'
  ;; (--map (format "%0x" it) ... )
  (should (equal
           (--map (format "%0x" it)
                  (png-phys-crc32-13 '(#x70 #x48 #x59 #x73 #x00 #x00 #x93 #xa3 #x00 #x00 #x93 #xa3 #x01)))
           '("d1" "b2" "f0" "c6")))
  (should (equal
           (--map (format "%0x" it)
                  (png-phys-crc32-13 '(0 0 0 0 0 0 0 0 0 0 0 0 0)))
           '("d2" "02" "ef" "8d"))))


(defun png-phys-pack (quartet)
  "Convert list of 4 bytes to 32-bit word.

QUARTET is a list of 4 integers in the range 0-255."
  (assert (equal (length quartet) 4))
  (let ((masks '(#xFF000000 #x00FF0000 #x0000FF00 #x000000FF))
        (register 0))
    (cl-loop for (index . (byte mask)) in (-zip '(0 1 2 3) quartet masks) do
             (setq register (logior register (logand mask (lsh byte (png-phys-byte-offset index))))))
    register))

(ert-deftest png-phys-pack--test ()
  (should (equal (png-phys-pack '(0 0 0 0)) 0))
  (should (equal (png-phys-pack '(0 0 0 1)) 1))
  (should (equal (png-phys-pack '(0 0 0 255)) 255))
  (should (equal (png-phys-pack '(0 0 1 0)) 256)))

(defun png-phys-pack-13 (bytes)
  "Convert list of bytes to list of packed 32-bit words.

BYTES is a list of integers in the range 0-255.
Pack these bytes into 32-bit ints.
The output is a list of ints."
  ;; For the pHYs crc32 checksum the input is a list of 13 bytes. We want to structure those
  ;; 13 bytes as 3 quartets (lists of 4) and one partial quartet (list of 1). We require
  ;; zero-padding on the left (in the first int). I.e. the list of 1 must hold the first
  ;; byte, and the subsequent 12 bytes are held in 3 full lists of 4.
  (assert (eq (length bytes) 13))
  (setq bytes (append '(0 0 0) bytes))
  (let ((registers '(0 0 0 0))
        (quartets (nreverse (mapcar #'nreverse (-partition 4 (nreverse bytes))))))
    (mapcar #'png-phys-pack quartets)))

(ert-deftest png-phys-pack-13--test ()
  (should (equal (png-phys-pack-13 '(0 0 0 0 0 0 0 0 0 0 0 0 0))
                 '(0 0 0 0)))
  (should (equal (png-phys-pack-13 '(0 0 0 0 0 0 0 0 0 0 0 0 #x1))
                 '(0 0 0 1)))
  (should (equal (png-phys-pack-13 '(0 0 0 0 0 0 0 0 0 0 0 0 #xFF))
                 '(0 0 0 255)))
  (should (equal (png-phys-pack-13 '(0 0 0 0 0 0 0 0 0 0 0 #x1 #x0))
                 '(0 0 0 #x100)))
  (should (equal (png-phys-pack-13 '(0 0 0 0 0 0 0 0 0 0 0 #x7 #x7))
                 '(0 0 0 #x707)))
  (should (equal (png-phys-pack-13 '(0 0 0 0 0 0 0 0 0 #x6 #x6 #x7 #x7))
                 '(0 0 0 #x06060707)))
  (should (equal (png-phys-pack-13 '(#x5 #x4 #x3 0 0 0 0 0 0 #x6 #x6 #x7 #x7))
                 '(#x5 #x4030000 0 #x6060707))))

(defun png-phys-unpack (word)
  "Convert 32-bit WORD to a list of 4 bytes.

A byte is represented as an integer in the range 0-255."
  (-map-indexed (lambda (index mask) (lsh (logand mask word) (- (png-phys-byte-offset index))))
                '(#xFF000000 #x00FF0000 #x0000FF00 #x000000FF)))

(ert-deftest png-phys-unpack--test ()
  (should (equal (png-phys-unpack 0) '(0 0 0 0)))
  (should (equal (png-phys-unpack 1) '(0 0 0 1)))
  (should (equal (png-phys-unpack 255) '(0 0 0 255)))
  (should (equal (png-phys-unpack 256) '(0 0 1 0))))

(defun png-phys-byte-offset (n)
  "Return bit offset of N-th byte.

N=0 for the most significant byte, and N=3 for the least significant."
  (* 8 (- 4 (1+ n))))

(if nil
    (png-set-phys (string-to-number (pop argv))
                  (f-read-bytes (pop argv))
                  (pop argv)))
